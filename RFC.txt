AETHER PROTOCOL SPECIFICATION
Draft 01 - February 2026

Authors: Valentin Nagacevschi
Status: Draft
Intended Status: Informational
Expires: August 2026

Abstract

   This document specifies Aether (AT), a binary messaging protocol 
   for autonomous agent communication. AT combines content-addressed 
   messaging with zero-copy serialization, supporting both real-time 
   signal transmission and conflict-free state synchronization. The 
   protocol is transport-agnostic but optimized for QUIC and provides 
   decentralized identity via Ed25519 public keys.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . .  2
   2.  Conventions and Terminology . . . . . . . . . . . . . . . .  3
   3.  Protocol Overview . . . . . . . . . . . . . . . . . . . . .  3
   4.  Event Structure . . . . . . . . . . . . . . . . . . . . . .  4
     4.1.  Event ID Calculation  . . . . . . . . . . . . . . . . .  5
     4.2.  Event Kinds . . . . . . . . . . . . . . . . . . . . . .  5
     4.3.  Tags  . . . . . . . . . . . . . . . . . . . . . . . . .  6
   5.  Wire Format . . . . . . . . . . . . . . . . . . . . . . . .  7
   6.  Relay Behavior  . . . . . . . . . . . . . . . . . . . . . .  8
     6.1.  Storage Policies  . . . . . . . . . . . . . . . . . . .  8
     6.2.  Subscription Filters  . . . . . . . . . . . . . . . . .  9
     6.3.  Compatibility Gateways . . . . . . . . . . . . . . . .  9
   7.  Client Behavior . . . . . . . . . . . . . . . . . . . . . .  9
   8.  Capability Delegation . . . . . . . . . . . . . . . . . . . 10
   9.  Proof-of-Work . . . . . . . . . . . . . . . . . . . . . . . 11
   10. Security Considerations . . . . . . . . . . . . . . . . . . 11
   11. References  . . . . . . . . . . . . . . . . . . . . . . . . 12

1. Introduction

   Aether (AT) is designed for machine-to-machine communication 
   where participants are autonomous agents rather than human users. 
   Unlike NOSTR [NIP-01], which uses JSON for human readability, AT 
   uses binary serialization (FlatBuffers) for zero-copy parsing and 
   reduced bandwidth consumption.
   
   The protocol maintains NOSTR's decentralized philosophy: clients 
   perform all validation and business logic, while relays provide 
   minimal storage and forwarding services. This "dumb relay, smart 
   client" architecture enables censorship-resistant communication 
   without federated consensus.

   Key features:
   o  Content-addressed events (Blake3 hashes) enabling deduplication
   o  Replaceable events for state synchronization (CRDT semantics)
   o  Ephemeral events for real-time signals (no storage)
   o  Capability-based delegation (macaroon-style attenuation)
   o  Tag-based routing supporting multi-dimensional filtering

2. Conventions and Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", 
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this 
   document are to be interpreted as described in RFC 2119 [RFC2119].

   Agent:       An autonomous software entity identified by an Ed25519 
                public key.
                
   Event:       A signed message containing content and metadata.
   
   Relay:       A server that accepts, stores, and forwards Events.
   
   Event ID:    The Blake3 hash of an Event's canonical serialization, 
                serving as a unique content identifier.
                
   Kind:        A 16-bit unsigned integer classifying Event semantics 
                and storage policies.
                
   Tag:         A key-value pair attached to an Event for routing and 
                referencing.

3. Protocol Overview

   AT operates over bidirectional byte streams (typically QUIC 
   connections). The protocol consists of three layers:

   Message Layer:    Length-prefixed FlatBuffers Message envelopes.
   Security Layer:   Ed25519 signatures over Event IDs.
   Transport Layer:  QUIC, TCP, or WebSocket (QUIC recommended).

   All participants generate Ed25519 keypairs for identity. No 
   registration or central authority is required. Agents discover 
   relays via bootstrap lists or DHT (implementation-specific).

   +--------+           Event (signed)          +--------+
   | Agent  | --------------------------------> | Relay  |
   |(Client)| <-------------------------------- |        |
   +--------+        Subscription Filter        +--------+
                            |
                            v
                       Other Agents

4. Event Structure

   An Event is a structured binary object with the following fields:

   event_id:     32 bytes, Blake3 hash (see Section 4.1)
   pubkey:       32 bytes, Ed25519 public key (compressed)
   kind:         uint16, classification (see Section 4.2)
   created_at:   uint64, Unix timestamp in nanoseconds
   tags:         Array of Tag structures
   content:      Variable-length opaque payload
   sig:          64 bytes, Ed25519 signature of event_id

4.1. Event ID Calculation

   The event_id is the Blake3 hash [BLAKE3] of the concatenation 
   of the following fields in network byte order:
   
   1. pubkey (32 bytes)
   2. created_at (8 bytes, big-endian)
   3. kind (2 bytes, big-endian)
   4. tags (serialized as: count [2 bytes] + tag data)
   5. content (raw bytes)

   The event_id serves as:
   - A unique identifier for deduplication
   - The signed payload (sig = Ed25519.sign(private_key, event_id))
   - A content-address for caching

4.2. Event Kinds

   Kind values determine storage semantics:

   0-999 (IMMUTABLE): Permanent storage. Relay MUST retain indefinitely.
       Kind 0: Agent metadata (JSON or FlatBuffers)

   10000-19999 (REPLACEABLE): Latest only. Relay MUST retain only the 
       most recent Event per (pubkey, kind) combination.
       Example: Kind 10001 = Current State Vector

   20000-29999 (EPHEMERAL): No storage. Relay MUST broadcast to current 
       subscribers but MUST NOT persist to disk.
       Example: Kind 29999 = Emergency Stop Signal

   30000-39999 (PARAMETERIZED_REPLACEABLE): Latest per parameter.
       Relay MUST retain latest per (pubkey, kind, d-tag) combination.
       Example: Kind 30001 = Task Template (d-tag = task_type)

   Relays MAY drop Events with kinds outside these ranges or implement 
   custom policies, but the above ranges MUST be supported for 
   interoperability.

4.3. Tags

   Tags provide multi-dimensional routing metadata. Each Tag consists 
   of:
   
   key:    1-8 ASCII characters (alphanumeric + underscore)
   values: Array of UTF-8 strings (max 16 values, 1024 bytes each)

   Standardized tag keys:
   
   "p":     Reference to another agent (pubkey hex)
   "e":     Reference to another Event (event_id hex)
   "c":     Capability required/ offered
   "d":     Identifier for parameterized replaceable events
   "g":     Geohash (spatial indexing)
   "t":     Topic/ taxonomy classification
   "expiration": Unix timestamp when event becomes invalid

   Example routing filter: ["c", "vision", "analysis", "high_res"]
   matches events tagged with capability "vision", sub-type "analysis", 
   quality "high_res".

5. Wire Format

   Aether defines two FlatBuffers schemas:
   - Event schema (`spec/schema.fbs`) for canonical Event structures.
   - Message envelope schema (`spec/message.fbs`) for transport frames.

   Transport frames use the Message envelope:

   namespace Aether;

   enum MessageType:ubyte {
     HELLO = 0,
     WELCOME = 1,
     PUBLISH = 2,
     SUBSCRIBE = 3,
     UNSUBSCRIBE = 4,
     EVENT = 5,
     ACK = 6,
     ERROR = 7,
     NOISE = 8
   }

   table Message {
     type: MessageType;
     payload: [ubyte];
   }

   root_type Message;

   The payload field contains UTF-8 JSON bytes for the logical message
   body (publish/subscribe/event/ack/error, etc.).

   On QUIC streams, frames are length-prefixed:
   [4 bytes: message length (big-endian)] [FlatBuffer Message]

   On WebSocket transport:
   - Binary frames carry FlatBuffer Message bytes.
   - Text frames carry JSON fallback messages.

   Handshake and negotiation:
   1. Client sends HELLO with supported formats and optional Noise key.
   2. Relay responds with WELCOME selecting format (`flatbuffers` or `json`).
   3. If Noise is required/negotiated, subsequent frames are wrapped in
      NOISE messages until disconnect.

   Implementations MUST support JSON fallback when FlatBuffers is not
   mutually available.

6. Relay Behavior

6.1. Storage Policies

   Upon receiving an Event, a Relay MUST:
   
   1. Validate event_id and signature against pubkey.
      If invalid, reject the publish request.
   
   2. Check if Event with identical event_id exists. If yes, discard 
      (idempotency).
   
   3. Apply kind-specific storage:
      - IMMUTABLE: Store indexed by created_at.
      - REPLACEABLE: Delete previous (pubkey, kind) Event, store new.
      - EPHEMERAL: Forward to subscribers, do not store.
      - PARAMETERIZED: Delete previous (pubkey, kind, d-tag), store new.

   4. Forward to all subscribers matching the Event's tags.

   Relays SHOULD enforce additional validation on publish:
   - kind range/policy checks
   - created_at window checks (RECOMMENDED: reject > 60s future skew)
   - max event size checks
   - rate limiting
   - optional PoW threshold

   Storage backend policy is implementation-specific. Current default
   deployment uses SQLite, with optional memory and RocksDB backends.
   Retention policy MAY prune old immutable events by configuration.

6.2. Subscription Filters

   Clients subscribe using filter objects with fields such as:
   - ids: [event_id] exact match
   - authors: [pubkey or prefix]
   - kinds: [uint16]
   - since / until: timestamp bounds
   - tags: key/value matches (e.g., `#d`, `#t`)
   - limit

   A Relay MUST deliver Events matching ALL provided filter fields
   (AND logic between fields, OR logic within array values).

6.3. Compatibility Gateways

   Relays MAY expose adapter gateways while preserving native Aether
   protocol semantics.

   NOSTR gateway scope (NIP-01 core):
   - Inbound: ["EVENT", <event>], ["REQ", <sub_id>, <filter...>], ["CLOSE", <sub_id>]
   - Outbound: ["OK", <event_id>, <bool>, <message>], ["EVENT", <sub_id>, <event>],
               ["EOSE", <sub_id>], ["NOTICE", <message>]

   HTTP gateway scope:
   - POST /v1/events
   - POST /v1/subscriptions
   - DELETE /v1/subscriptions/{id}
   - GET /v1/stream?subscription_id=... (SSE)
   - GET /healthz
   - WebSocket JSON endpoint: /v1/ws

7. Client Behavior

   Agents (clients) MUST:
   
   o  Generate cryptographically secure Ed25519 keypairs
   o  Maintain monotonic clocks (NTP or better) for created_at
   o  Verify all relay-provided Events before processing
   o  Handle replaceable Events by overwriting local state
   o  Implement exponential backoff for relay reconnection

   Agents SHOULD:
   
   o  Connect to 3-5 relays for redundancy
   o  Publish critical Events to multiple relays concurrently
   o  Cache event_ids for 60 seconds to suppress duplicates
   o  Use ephemeral Events (kind 20000+) for heartbeats < 1s interval

8. Capability Delegation

   Agents MAY delegate capabilities using chained delegation tokens 
   stored in content fields. The delegation chain is verified 
   client-side (relays are unaware).

   Delegation structure:
   - issuer: 32-byte Ed25519 pubkey
   - subject: 32-byte Ed25519 pubkey
   - capability: string (e.g., "storage:write:bucket_a")
   - caveats: key/value constraints (e.g., expiry, not_before, max_uses)
   - signature: Ed25519(issuer, token_id)

   token_id is computed as:
   BLAKE3(canonical_json(issuer, subject, capability, caveats))

   Capability offers MAY be carried in Kind 10002 events, including
   optional Lightning invoice attachment metadata.

9. Proof-of-Work

   For open networks vulnerable to spam, Relays MAY require 
   Proof-of-Work (PoW) on Events.

   PoW difficulty is defined as the number of leading zero bits in 
   the event_id. Clients grind the created_at field or a nonce in 
   content to find valid hashes.

   Relays advertise minimum difficulty via INFO messages 
   (implementation-specific). Difficulty SHOULD scale dynamically 
   with network load.

   PoW is OPTIONAL and typically only required for Kind 0 (metadata) 
   or initial bootstrap to prevent Sybil attacks.

10. Security Considerations

   10.1. Signature Verification
   
   Implementations MUST verify Ed25519 signatures in constant-time 
   to prevent timing attacks. Use established libraries (libsodium, 
   ed25519-dalek, etc.).

   10.2. Replay Protection
   
   The created_at field provides weak ordering. Relays SHOULD reject 
   Events with timestamps > 60 seconds in the future. Clients SHOULD 
   ignore Events with timestamps older than their subscription start 
   unless explicitly requested (historical sync).

   10.3. Content Security
   
   Relays MUST NOT parse or execute content payloads. Agents MUST 
   sandbox content processing (e.g., FlatBuffers schema validation) 
   to prevent malicious payloads from compromising the agent.

   10.4. Privacy
   
   Event content is visible to all relays and subscribers. Agents 
   SHOULD encrypt sensitive content using the Noise Protocol or 
   similar before embedding in Events.

   10.5. Denial of Service
   
   Replaceable Events prevent storage exhaustion from state updates. 
   Relays SHOULD rate-limit by pubkey and implement PoW for 
   unauthenticated networks.

11. References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate 
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [NIP-01]   NOSTR Protocol, "NIP-01: Basic Protocol Flow", 
              https://github.com/nostr-protocol/nips/blob/master/01.md

   [BLAKE3]   O'Connor, J., et al., "BLAKE3: One function, fast 
              everywhere", 2020.

   [FLATBUFFERS]  FlatBuffers: Efficient cross platform serialization 
                  library, Google.

   [NOISE]    Perrin, T., "The Noise Protocol Framework", 
              https://noiseprotocol.org/noise.html
